/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-licenses",
factory: function (require) {
var plugin=(()=>{var se=Object.create,U=Object.defineProperty;var re=Object.getOwnPropertyDescriptor;var ae=Object.getOwnPropertyNames,_=Object.getOwnPropertySymbols,ce=Object.getPrototypeOf,z=Object.prototype.hasOwnProperty,le=Object.prototype.propertyIsEnumerable;var K=(e,n,t)=>n in e?U(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,F=(e,n)=>{for(var t in n||(n={}))z.call(n,t)&&K(e,t,n[t]);if(_)for(var t of _(n))le.call(n,t)&&K(e,t,n[t]);return e};var de=e=>U(e,"__esModule",{value:!0});var p=e=>{if(typeof require!="undefined")return require(e);throw new Error('Dynamic require of "'+e+'" is not supported')};var W=(e,n)=>{for(var t in n)U(e,t,{get:n[t],enumerable:!0})},pe=(e,n,t)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of ae(n))!z.call(e,i)&&i!=="default"&&U(e,i,{get:()=>n[i],enumerable:!(t=re(n,i))||t.enumerable});return e},f=e=>pe(de(U(e!=null?se(ce(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var Te={};W(Te,{default:()=>ve});var ee=f(p("@yarnpkg/cli")),b=f(p("@yarnpkg/core")),w=f(p("clipanion"));var r=f(p("@yarnpkg/core")),u=f(p("@yarnpkg/fslib"));var A={};W(A,{fs:()=>me,getPackagePath:()=>fe});var q=f(p("@yarnpkg/plugin-pnp")),$=f(p("@yarnpkg/core")),S=f(p("@yarnpkg/fslib")),J=f(p("@yarnpkg/libzip")),fe=async(e,n)=>{ue(e);let t=$.structUtils.convertPackageToLocator(n),i={name:$.structUtils.stringifyIdent(t),reference:t.reference},o=R.getPackageInformation(i);if(!o)return null;let{packageLocation:c}=o;return c},R,ue=e=>{R||(R=module.require((0,q.getPnpPath)(e).cjs))},me=new S.VirtualFS({baseFs:new S.ZipOpenFS({libzip:(0,J.getLibzipSync)(),readOnlyArchives:!0})});var H={};W(H,{fs:()=>Pe,getPackagePath:()=>ge});var C=f(p("@yarnpkg/core")),Y=f(p("@yarnpkg/parsers")),y=f(p("@yarnpkg/fslib")),ge=async(e,n)=>{await he(e);let t=C.structUtils.convertPackageToLocator(n),i=x[C.structUtils.stringifyLocator(t)];if(!i){console.log("getPackagePath entry lookup failed..."),console.log("looking for:",C.structUtils.stringifyLocator(t));let c=t.scope?`@${t.scope}/${t.name}`:t.name,d=t.reference.slice(t.reference.lastIndexOf(":")),s=Object.keys(x).filter(l=>l.startsWith(c)&&l.endsWith(d));console.log("found these in the yarnState:",s);let a=Object.keys(x).find(l=>l.startsWith(c)&&l.endsWith(d));if(console.log("using this one instead:",a),!a)return console.log("nothing found"),null;i=x[a]}let o=i.locations[0];return o?y.ppath.join(e.cwd,o):e.cwd},x,he=async e=>{if(!x){let n=y.ppath.join(e.configuration.projectCwd,y.Filename.nodeModules,".yarn-state.yml");x=(0,Y.parseSyml)(await y.xfs.readFilePromise(n,"utf8"))}},Pe=y.xfs;var B=e=>{switch(e){case"pnp":return A;case"node-modules":return H;default:throw new Error("Unsupported linker")}};var We=u.npath.basename(__dirname)==="@yarnpkg"?u.ppath.join(u.npath.toPortablePath(__dirname),"../.."):u.ppath.join(u.npath.toPortablePath(__dirname),".."),Z=async(e,n,t,i,o)=>{let c={},d={children:c},s=await G(e,t,i),a=B(e.configuration.get("nodeLinker"));for(let[l,g]of s.entries()){let h=await a.getPackagePath(e,g);if(h===null)continue;let v=JSON.parse(await a.fs.readFilePromise(u.ppath.join(h,u.Filename.manifest),"utf8")),{license:m,url:N,vendorName:T,vendorUrl:L}=ye(v);c[m]||(c[m]={value:r.formatUtils.tuple(r.formatUtils.Type.NO_HINT,m),children:{}});let M=r.structUtils.convertPackageToLocator(g),P=r.formatUtils.tuple(r.formatUtils.Type.DEPENDENT,{locator:M,descriptor:l}),k=o?{}:F(F(F({},N?{url:{value:r.formatUtils.tuple(r.formatUtils.Type.NO_HINT,V("URL",N,n))}}:{}),T?{vendorName:{value:r.formatUtils.tuple(r.formatUtils.Type.NO_HINT,V("VendorName",T,n))}}:{}),L?{vendorUrl:{value:r.formatUtils.tuple(r.formatUtils.Type.NO_HINT,V("VendorUrl",L,n))}}:{}),ne={value:P,children:k},ie=r.structUtils.stringifyLocator(M),oe=c[m].children;oe[ie]=ne}return d},G=async(e,n,t)=>{let i=new Map,o;if(n){if(t){for(let a of e.workspaces)a.manifest.devDependencies.clear();let s=await r.Cache.find(e.configuration);await e.resolveEverything({report:new r.ThrowReport,cache:s})}o=e.storedDescriptors.values()}else o=e.workspaces.flatMap(s=>{let a=[s.anchoredDescriptor];for(let[l,g]of s.dependencies.entries())t&&s.manifest.devDependencies.has(l)||a.push(g);return a});let c=r.miscUtils.sortMap(o,[s=>r.structUtils.stringifyIdent(s),s=>r.structUtils.isVirtualDescriptor(s)?"0":"1",s=>s.range]),d=new Set;for(let s of c.values()){let a=e.storedResolutions.get(s.descriptorHash);if(!a)continue;let l=e.storedPackages.get(a);if(!l)continue;let{descriptorHash:g}=r.structUtils.isVirtualDescriptor(s)?r.structUtils.devirtualizeDescriptor(s):s;d.has(g)||(d.add(g),i.set(s,l))}return i};function ke(e){let n={},t=e.match(/^([^(<]+)/);if(t){let c=t[0].trim();c&&(n.name=c)}let i=e.match(/<([^>]+)>/);i&&(n.email=i[1]);let o=e.match(/\(([^)]+)\)/);return o&&(n.url=o[1]),n}var ye=e=>{let{license:n,licenses:t,repository:i,homepage:o,author:c}=e,d=typeof c=="string"?ke(c):c;return{license:(()=>{if(n)return D(n);if(t){if(!Array.isArray(t))return D(t);if(t.length===1)return D(t[0]);if(t.length>1)return`(${t.map(D).join(" OR ")})`}return Q})(),url:(i==null?void 0:i.url)||o,vendorName:d==null?void 0:d.name,vendorUrl:o||(d==null?void 0:d.url)}},Q="UNKNOWN",D=e=>(typeof e!="string"?e.type:e)||Q,V=(e,n,t)=>t?n:`${e}: ${n}`,X=async(e,n,t)=>{let i=await G(e,n,t),o=B(e.configuration.get("nodeLinker")),c=new Map;for(let s of i.values()){let a=await o.getPackagePath(e,s);if(a===null)continue;let l=JSON.parse(await o.fs.readFilePromise(u.ppath.join(a,u.Filename.manifest),"utf8")),h=(await o.fs.readdirPromise(a,{withFileTypes:!0})).filter(P=>P.isFile()).map(({name:P})=>P),v=h.find(P=>{let k=P.toLowerCase();return k==="license"||k.startsWith("license.")||k==="unlicense"||k.startsWith("unlicense.")});if(!v)continue;let m=await o.fs.readFilePromise(u.ppath.join(a,v),"utf8"),N=h.find(P=>{let k=P.toLowerCase();return k==="notice"||k.startsWith("notice.")}),T;N&&(T=await o.fs.readFilePromise(u.ppath.join(a,N),"utf8"));let L=T?`${m}

NOTICE

${T}`:m,M=c.get(L);M?M.set(l.name,l):c.set(L,new Map([[l.name,l]]))}let d=`THE FOLLOWING SETS FORTH ATTRIBUTION NOTICES FOR THIRD PARTY SOFTWARE THAT MAY BE CONTAINED IN PORTIONS OF THE ${String(e.topLevelWorkspace.manifest.raw.name).toUpperCase().replace(/-/g," ")} PRODUCT.

`;for(let[s,a]of c.entries()){d+=`-----

`;let l=[],g=[];for(let{name:v,repository:m}of a.values())l.push(v),(m==null?void 0:m.url)&&g.push(a.size===1?m.url:`${m.url} (${v})`);let h=[];h.push(`The following software may be included in this product: ${l.join(", ")}.`),g.length>0&&h.push(`A copy of the source code may be downloaded from ${g.join(", ")}.`),h.push("This software contains the following license and notice below:"),d+=`${h.join(" ")}

`,d+=`${s.trim()}

`}return d};var O=class extends w.Command{constructor(){super(...arguments);this.recursive=w.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=w.Option.Boolean("--production",!1,{description:"Exclude development dependencies"});this.json=w.Option.Boolean("--json",!1,{description:"Format output as JSON"});this.excludeMetadata=w.Option.Boolean("--exclude-metadata",!1,{description:"Exclude dependency metadata from output"})}async execute(){let n=await b.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:i}=await b.Project.find(n,this.context.cwd);if(!i)throw new ee.WorkspaceRequiredError(t.cwd,this.context.cwd);await t.restoreInstallState();let o=await Z(t,this.json,this.recursive,this.production,this.excludeMetadata);b.treeUtils.emitTree(o,{configuration:n,stdout:this.context.stdout,json:this.json,separators:1})}};O.paths=[["licenses","list"]],O.usage=w.Command.Usage({description:"display the licenses for all packages in the project",details:`
      This command prints the license information for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the listing will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the listing will exclude development dependencies.
    `,examples:[["List all licenses of direct dependencies","$0 licenses list"],["List all licenses of direct and transitive dependencies","$0 licenses list --recursive"],["List all licenses of production dependencies only","$0 licenses list --production"]]});var te=f(p("@yarnpkg/cli")),E=f(p("@yarnpkg/core")),I=f(p("clipanion"));var j=class extends I.Command{constructor(){super(...arguments);this.recursive=I.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=I.Option.Boolean("--production",!1,{description:"Exclude development dependencies"})}async execute(){let n=await E.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:i}=await E.Project.find(n,this.context.cwd);if(!i)throw new te.WorkspaceRequiredError(t.cwd,this.context.cwd);await t.restoreInstallState();let o=await X(t,this.recursive,this.production);this.context.stdout.write(o)}};j.paths=[["licenses","generate-disclaimer"]],j.usage=I.Command.Usage({description:"display the license disclaimer including all packages in the project",details:`
      This command prints the license disclaimer for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the disclaimer will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the disclaimer will exclude development dependencies.
    `,examples:[["Include licenses of direct dependencies","$0 licenses generate-disclaimer"],["Include licenses of direct and transitive dependencies","$0 licenses generate-disclaimer --recursive"],["Include licenses of production dependencies only","$0 licenses list --production"]]});var we={commands:[O,j]},ve=we;return Te;})();
return plugin;
}
};
